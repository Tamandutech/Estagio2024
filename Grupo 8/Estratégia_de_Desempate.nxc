/*
==============================================================================================================================================================================================

Nome da Estratégia(Código): Estratégia de Desempate

Descrição: Este código controla um robô sumô utilizando dois motores e um sensor de distância.
O objetivo é manter uma distância segura do oponente, ajustando a velocidade dos motores com base na diferença entre a leitura do sensor e um valor de referência.
A função `Movimentacao_Defesa()` aplica um controle proporcional (PID simplificado) para corrigir a direção do robô, compensando o erro de distância.
Se o robô detectar que o oponente está muito próximo (<= 30 cm), ele se move para frente rapidamente. Caso contrário, ele continua a se mover com correção defensiva.
No início da função `main()`, os motores são ativados em direções opostas (`OnFwd(motorDireita, 80);` e `OnFwd(motorEsquerda, -80);`), fazendo o robô girar sobre seu próprio eixo.
Este movimento inicial ajuda o robô a escanear o ambiente ao seu redor, utilizando o sensor de distância para detectar a posição do oponente antes de aplicar a estratégia de defesa.

Usamos no Combate de Sumô: Não, pois a lógica do código não apresentou ser muito efetiva e eficaz, fazendo com que a equipe ficasse com dúvidas do desempenho do código durante a luta.

==============================================================================================================================================================================================
*/

//Definições dos Motores e Sensores
#define motorDireita OUT_A                  //Motor Direito --> entrada A
#define motorEsquerda OUT_C                //Motor Esquerdo --> entrada C
#define distancia_sensor SensorUS(IN_1)   //Sensor de Sistancia Entrada 4

int Referencia = 30;
const float Kp = 4.0;   //Constante Proporcional
int Erro;
int Forca = 80;
int Correcao;
int Velocidade_OUT_A;
int Velocidade_OUT_C;

//Função de Movimentação com Fator de Correção PID
void Movimentacao_Defesa()
{
    Erro = distancia_sensor - Referencia;
    Correcao = Erro * Kp;
    Velocidade_OUT_A = Forca + Correcao;
    Velocidade_OUT_C = Forca - Correcao;

    OnFwd(motorDireita, Velocidade_OUT_A);
    OnFwd(motorEsquerda, Velocidade_OUT_C);
}

task main()
{
    SetSensorLowspeed(IN_1);   //NÃO MEXER SUJEITO À >>>PROBLEMAS<<<
    Wait(5000);               //Tempo de espera previsto nas regras
    
    OnFwd(motorDireita, 80);
    OnFwd(motorEsquerda, -80);
    
    while (true)
    {
        if (distancia_sensor<=30) {
            OnFwd(motorDireita, -100);
            OnFwd(motorEsquerda, -100);
        } else {
            Movimentacao_Defesa();
        }
    }
}
